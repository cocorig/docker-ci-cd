# Docker 🐳

`Docker`는 애플리케이션을 개발, 제공 및 실행하기 위한 개방형 플랫폼으로, Docker를 사용하면
개발자는 동일한 환경애서 애플리케이션을 개발하고, Docker 이미지를 사용해 테스트 및 프로덕션 환경에 배포할 수 있기 때문에 개발 환경과 프로덕션 환경의 실행 지연 시간을 크게 줄일 수 있다.

## 컨테이너화 (Containerization)

![스크린샷 2024-04-03 오전 2 45 32](https://github.com/cocorig/docker-ci-cd/assets/95855640/b2bc9ebf-99a6-453e-a174-59467566f7c4)

1960-70년대에는 일반적으로 한 컴퓨터가 한 애플리케이션 실행을 담당했기 때문에 프로세스 관리도 오래 걸렸다. 이 시기에는 `커널`이 `프로세스`의 생성부터 종료까지 전 생명 주기를 관리하고, 프로세스들이 `시스템 자원`을 효율적으로 사용하도록 조정하는 역할을 수행했다. 이를 통해 사용자와 애플리케이션은 안정적이고 효율적인 시스템 환경에서 작업을 수행할 수 있었다.

그러나 컴퓨팅 환경이 발전함에 따라 다중 사용자 및 다중 애플리케이션 환경이 보편화되면서 이러한 방식의 한계가 발생했다. 컴퓨터 자원을 최대한 공유하여 프로세스를 빠르게 실행하려 했지만, 서로 다른 사용자 간에 리소스를 공유하는 경우에는 각각의 프로세스가 원하는 리소스를 충분히 확보하지 못할 수 있는 문제가 발생했다. <br>
즉 효율적으로 사용하려면 자원을 분리해서 사용해야 되는 것이다. 이러한 문제를 해결하기 위해 가상화 기술(Virtual Machine)이 도입되었다. `하이퍼바이저 가상화`는 하드웨어 상에 여러 개의 독립적인 가상 운영 체제(가상 머신)를 실행할 수 있게 해주는 기술이다. 가상화를 통해 하나의 물리적 시스템에서 여러 개의 가상 환경을 만들어 각각의 환경에서 독립적으로 애플리케이션을 실행할 수 있게 되었다. `하이퍼바이저 가상화의 핵심`은 하이퍼바이저라는 소프트웨어에 있다. 하이퍼바이저는 물리적 하드웨어와 가상 머신 사이에서 `중재자 역할`을 하며, 하드웨어 자원(CPU, 메모리, 스토리지 등)을 가상 머신에게 분배하고, 가상 머신들이 이 자원을 안전하고 효율적으로 사용할 수 있도록 관리한다. <br>
이러한 가상화를 통해, 개발자는 `다양한 운영 체제 위`에서 애플리케이션을 `테스트`하고, IT 관리자는 서버를 더 효율적으로 활용하여 비용을 절감할 수 있다.
또한, 하나의 리눅스 커널 위에서 여러 개의 독립적인 사용자 공간 인스턴스를 실행할 수 있게 해준다. VM과 다른 방법을 사용해서 효율 성능이 더 나아진게 `컨테이너`이다.
`컨테이너 가상화`는 애플리케이션을 실행하는 데 필요한 코드, 런타임, 시스템 도구, 시스템 라이브러리 등을 가상 머신포함하는 `가벼운 격리된 환경`을 생성하는 기술이다.
리눅스의 두 가지 격리 기술(Control Groups, Namespace)을 기반으로 사용함으로써, `컨테이너 가상화`는 각 컨테이너에게 완전히 독립된 시스템처럼 보이는 환경을 제공한다. 이는 개발자가 애플리케이션을 개발하고 배포할 때 발생할 수 있는 문제를 줄여줄 수 있다.

여기서 컨테이너와 가상 머신의 유사점과 차이점을 알아보자.

## 컨테이너와 VM(가상 머신) 비교

- `유사점` <br>
  같은 가상기술로서 도커와 가상 머신은 모두 이미지에서 생성된다. 각 이미지를 사용하면 개발자는 환경을 매번 구성하지 않고 일관된 환경을 만들고 공유할 수 있게된다. 가상 머신 이미지는 운영 체제 백업을 생성하고,반면 도커 컨테이너 이미지는 애플리케이션 환경 백업을 생성한다. <br>
  또한 각 이미지 모두 버전 관리를 통해 환경 구성 변경을 추적할 수 있고, 모두 서로 다른 유형의 기본 아키텍처에 대해 서로 다른 애플리케이션 구성을 개발해야 하는 어려움을 해결하도록 설계되었다.

- `차이점` <br>
  가상 머신은 하드웨어에 `미리 일정량의 리소스를 요청`하며 가상 머신이 실행되는 한 계속해서 해당 양만큼 사용하고, 반면 컨테이너는 가상 머신과 달리 , `단일 운영 체제 커널`에서 `필요한 리소스만 `요청해 여러 컨테이너가 동일한 운영 체제를 공유하기 때문에 여러 컨테이너가 동일한 시스템에서 실행될 수 있으며 커널을 다른 컨테이너와 공유할 수 있다.
  또한 컨테이너 이미지의 크기는 일반적으로 MB이기 때문에 더 많은 애플리케이션을 처리할 수 있고, 가상 머신에 비해 더 적은 수의 가상 머신 및 운영 체제가 필요하기 때문에 더 가볍다.
  또한 VM은 애플리케이션의 종속성과 커널 및 호스트 운영 체체와 함께 실행되고, 도커 컨테이너에는 종속성(애플리케이션과 라이브러리 등)만 포함되기 때문에 도커가 더 가볍다고 할 수 있다. 반면 가상 머신은 가상 머신 안에서 실행되는 운영 체제인 게스트 운영 체제(guest operating system)이 포함되고, 이 가상머신은 하이퍼바이저를 사용해 단일 시스템에서 여러 VM을 실행할 수 있지만, 각각의 VM이 완전한 운영 체제 및 응용 프로그램을 갖고 있기 때문에, 가상 머신이 실행되는 데에는 해당 운영 체제와 관련된 모든 것이 필요하므로 전체 복사본이 필요하므로, GB를 차지한다. 따라서 VM의 부팅 속도도 느려질 수 있다.

## 도커 주요 장점

1.  Docker 컨테이너는 가상 머신에 비해 작고 가볍기 때문에 컨테이너를 개발, 테스트 및 배포를 더 빠르게 수행할 수 있다.
2.  어떤 환경에서든 동일하게 실행될 수 있기 때문에 어디든 쉽게 이동해 사용할 수 있다.(이식성)
3.  여러 플랫폼에 배포할 구 있는 기능을 갖추고 있다.
4.  Docker는 하이퍼바이저를 사용하지 않기 때문에 사용 가능한 리소스를 보다 효율적으로 사용한다.
5.  테스트 및 프로덕션과 같은 `다양한 환경`에 애플리케이션 `배포` 시의 `문제를 해결`할 수 있다.

## 용어정리

- `Docker Image` : Image는 애플리케이션 실행에 필요한 모든 것을 포함한다. 예를 들어
  애플리케이션과 관련된 라이브러리, 환경 변수 및 설정 파일,코드 등을 예로 들 수 있다.
  그럼 Docker Image는 Docker container를 실행하는 데 필요한 모든 것을 포함하는 것으로, 애플리케이션을 다양한 환경에서 일관되게 실행할 수 있다. 즉, container를 실행하기 위한 `불변의 템블릿`이라고 할 수 있다.(도장처럼 계속 사용가능하다.)
  또한, Docker Image는 여러 계층(layer)으로 구성되어 있으며,각 계층은 파일 시스템의 변경 사항을 저장한다. 일반적으로 도커허브와 같은 레지스트리에서 가져오거나 Dockerfile을 사용해 직접 빌드할 수 있다.
- `Docker container` : Docker container는 Docker Image의 `실행 인스턴스`이다.
  container는 Image를 기반으로 실행되며, 격리된 횐경에서 애플리케이션과 의존성을 `캡슐화` 하기 때문에 개발자는 동일한 Image를 사용하여 여러 container를 동시에 실행할 수 있으며, 각 container는 `독립적`으로 실행되고 관리된다. 즉 한 container의 문제가 다른 container에 영향을 미치지 않는다.
- `하이퍼바이저` : 가상화 환경을 생성하고, 관리하는 소프트웨어이다.
  주요 역할은 하나의 물리적 시스템 상에 `여러 개의 독립된 가상 머신(VM)을 실행`할 수 있는 환경을 제공하는 것이다.
- `리소스 관리`: 도커 엔진은 Cgroups와 네임스페이스와 같은 리눅스의 핵심 기능을 사용하여 컨테이너의 리소스 사용량을 제한하고, 컨테이너 간의 격리를 유지한다. 이를 통해 시스템의 안정성을 보장하고, 다른 컨테이너나 시스템 전체에 부정적인 영향을 미치는 것을 방지한다.

## 도커를 배우는 이유?

개발 단계에서 오류가 발생하지 않더라도 배포 후에 예상치 못한 문제가 발생할 수 있기 때문에
애플리케이션의 안정성을 점검하고 싶었고, 개발환경과 운영환경을 일치시키기 편리하기 때문이다.

## 왜 배포가 편리해야 할까?

서비스나 애플리케이션의 안정성이나 기능에 문제가 발생할 경우, 빠르게 수정하고 배포해야 한다. 안정성이 떨어지면 사용자들의 신뢰도가 저하되고 비즈니스에 부정적인 영향을 미칠 수 있으므로 빠른 대응이 필요하다.
또한 효율적인 배포는 운영 비용을 절감할 수 있다. 수동 작업이 줄어들고 자동화된 프로세스를 통해 운영 및 유지보수 비용을 최소화할 수 있다.

## 도커의 구성요소

도커 엔진 (Docker Engine)은 컨테이너를 생성하고 관리하는 기능을 제공하는 `클라이언트-서버 형태`의 애플리케이션이다.

1.  `Docker 클라이언트 및 서버` <br>
    도커 데몬은 모든 컨테이너로 구성되며, CLI 또는 REST API를 통해 Docker 클라이언트로부터 요청을 수신하고, 처리한다. 또한 컨테이너의 생성, 실행, 중지와 같은 생명 주기를 관리한고, 도커 데몬은 다른 도커 클라이언트의 명령을 수행하기 위해 REST API를 통해 접근할 수 있다.
2.  `Docker 이미지` <br>
    Docker 컨테이너를 빌드하는 데 사용된다.
3.  `Dockerfile` <br>
    Docker 이미지를 자동으로 빌드하기 위한 스크립트 파일이다.이 이미지는 프로젝트의 종속성과 코드가 포함된다. 또한 docker build 명령어와 함께 사용되어 새로운 도커 이미지를 생성한다.
4.  `Docker 레지스트리` <br>
    도커 이미지를 저장하고 배포하기 위한 서버 측 응용 프로그램이다. 보안, 액세스 제어, 저장소 한계 설정 등을 사용자가 직접 구성할 수 있게 해주며, 개인 또는 조직 내부에서 사용할 수 있는 프라이빗 저장소를 만들 수 있게 해준다.
5.  `Docker 컨테이너` <br>
    이미지를 기반으로 하여 실행된다.

## 도커 구조

![Group 6](https://github.com/cocorig/docker-ci-cd/assets/95855640/9e992a75-b268-4566-b915-4201532736f2)

도커 아키텍처는 도커 클라이언트, 도커 호스트에서 실행되는 도커 데몬, 도커 허브 리포지토리로 구성된다.

- `Docker 이미지를 빌드`

  - (1) Docker Daemon에 대한 `빌드 명령`을 실행한다
  - (2) Docker Daemon은 해당 입력에 기반하여 `이미지를 빌드`한다.
  - (3) 빌드된 이미지를 Docker `레지스트리에 저장`한다.

- `이미지를 생성하지 않으려면`

  - (4) 클라이언트에서 `pull 명령`을 실행하여 Docker Daemon이 Docker Hub에서 이미지를 가져오도록 한다.

- `이미지를 실행하려는 경우`

  - (5) 클라이언트에서 `run 명령`을 실행
  - (6) 해당 이미지가 `컨테이너로 생성`된다.

## 동작방식

![Group 7](https://github.com/cocorig/docker-ci-cd/assets/95855640/59232d10-ee87-427d-afd1-2285452e58ce)

1. `이미지 다운로드 또는 빌드` <br>
   컨테이너를 실행하기 전에, 도커 엔진은 해당 애플리케이션을 실행하는 데 필요한 모든 파일과 설정이 포함된 도커 이미지가 필요하다. 사용자는 도커 허브나 다른 이미지 저장소에서 이미지를 다운로드하거나, Dockerfile을 정의하고 이를 통해 새로운 이미지를 빌드할 수 있다.
2. `컨테이너 생성` <br>
   이미지가 준비되면, 사용자는 도커 데몬에게 컨테이너 생성을 요청한다. 이때, 네트워크 설정이나 볼륨 마운트와 같은 추가적인 옵션을 지정할 수 있다. 도커 데몬은 이러한 정보를 바탕으로 새로운 컨테이너의 인스턴스를 생성한다.
3. `컨테이너 실행` <br>
   컨테이너가 생성되면, 도커 데몬은 컨테이너 내부에서 정의된 애플리케이션을 실행한다. 이 과정에서 컨테이너는 독립된 파일 시스템, 네트워크 인터페이스, 프로세스 ID 공간 등을 갖게 되며, 이는 컨테이너를 호스트 시스템과 격리된 환경에서 실행되게 한다.
4. `컨테이너 관리` <br>
   도커 엔진은 실행 중인 컨테이너의 상태를 모니터링하고 관리한다. 사용자는 도커 CLI를 통해 실행 중인 컨테이너를 조회하고, 로그를 확인하며, 필요한 경우 컨테이너를 중지, 재시작 또는 삭제할 수 있다.

## Docker Compose 개념

- 예시

```yaml
# docker 컨테이너 버전 명시, 일반적으로 최신 버전을 사용하는 것이 좋다.
version: "3"

# services는 애플리케이션을 구성하는 컨테이너들을 정의한다.각 서비스는 하나의 컨테이너를 의미.
services:
  db:
    # 컨테이너 이름 설정
    container_name:
    # 컨테이너 재시작 정책 설정
    restart: always
    image:
    ports:
      -
    # 볼륨는 데이터를 영구적으로 저장하기 위한 볼륨을 정의하고, 여러 컨테이너 간에 데이터를 공유할 수 있도록 한다.
    volumes:
      -
    # 네트워크는 컨테이너 간 통신을 위한 네트워크를 정의한다.
    networks:
      app-network:
    # 환경 변수 설정
    environment:
      POSTGRES_USER:
      POSTGRES_PASSWORD:
      POSTGRES_DB:
```

Docker Compose는 여러 컨테이너 애플리케이션을 손쉽게 관리할 수 있는 도구로 여러 개의 컨테이너로 구성된 애플리케이션을 더 간편하게 구성하고 실행할 수 있다. 예를 들어 react와 PostgreSQL이 필요한 애플리케이션을 만들고자 한다면, 이 두 컨테이너를 하나의 YAML 파일에 서비스로 정의할 수 있다. <br>
YAML 파일은 파일 하나로 전체 애플리케이션 스택의 설정을 관리할 수 있고, 애플리케이션의 서비스, 네트워크, 볼륨 ,환경 변수 등으로 구성하며, 이 파일을 기반으로 한 명령어로 모든 서비스를 빌드하고 시작할 수 있다. 또한 개발, 테스팅, 스테이징, 프로덕션 환경에서의 일관성을 보장하는 데 유용하다!!
[Try Docker Compose](https://docs.docker.com/compose/gettingstarted/)
<br>

### 정리

[Compose 작성 템플릿 코드](https://github.com/docker/awesome-compose)

```bash
docker compose up
```

```bash
docker-compose down
```

## Volumes

![Group 16](https://github.com/cocorig/docker-ci-cd/assets/95855640/ac661e1a-71d6-4a04-af3c-e2b924b6ef36)

> 쉽게 보기위해 그린 이미지로 실제 동작과 다를 수 있습니다. 😅

볼륨은 도커가 관리하는 데이터의 저장소이다. 주로 테스트 환경에서 데이터를 백업하고 필요할 때 복구하는 것이 용이하다.
볼륨은 컨테이너와 `독립적으로 존재`하고 도커가 관리하기 때문에 데이터를 보관할 수 있고, 하나 이상의 컨테이너에서 사용할 수 있다. 또한 다른 여러 컨테이너 간에 `데이터를 공유`하거나 데이터의 지속적인 저장이 필요한 경우에 적합하기 때문에 이식성이 높다.
주의할 점은 볼륨은 도커의 관리 하에 있기 때문에, 호스트 시스템의 파일 시스템 경로를 직접 지정할 수 없다.

### Volumes 명령어

- 새로운 볼륨을 생성한다.

```bash
docker volume create
```

- 생성된 볼륨 목록을 조회한다.

```bash
docker volume ls
```

- 지정한 볼륨을 삭제한다.

```bash
docker volume inspect
```

- 지정한 볼륨의 상세 정보를 조회한다.

```bash
docker-compose down
```

## Docker 기본 명령어

- 현재 실행 중인 컨테이너 목록을 표시

```bash
docker ps
```

- Docker 엔진의 버전을 표시

```bash
docker --version
```

- 새로운 컨테이너를 실행

```bash
docker run
```

docker run = docker pull + docker create + docker start

- Docker 이미지를 다운로드

```bash
docker pull

```

- 컨테이너를 생성, 실행 x

```bash
docker create
```

- 정지된 컨테이너를 시작

```bash
docker start
```

- 실행 중인 컨테이너를 중지

```bash
docker stop
```

- 실행 중인 컨테이너를 다시 시작

```bash
docker restart
```

- 컨테이너 제거

```bash
docker rm 컨테이너 이름
```

- 이미지 제거(컨테이너 삭제 후 진행해야함)

```bash
docker rmi 이미지 이름
```

- 이미지 빌드

```bash
docker build
```

<br>

## 로컬 환경에서 Docker 실행

```bash
cd spring-docker-demo

```

```bash
./mvnw clean package

```

```bash
docker build -t spring-helloworld .

```

### -p 와 -d 옵션의 차이점

```bash
docker run -p 8080:8080 -t spring-helloworld

```

```bash
docker run -d -p 8080:8080 -t spring-helloworld
```

- -d, --detach <br>
  Run container in `background` and print container ID
- -p, --publish <br>
  Publish a container's port(s) to the host

## DockerFile 작성하기

Dockerfile은 `도커 이미지를 구축하기 위해` 명령어들을 순차적으로 나열한 텍스트 파일이다. 각각의 명령어는 이미지의 새로운 계층을 만들어 내며, 이러한 계층들이 합쳐져 최종적인 이미지를 형성한다. Dockerfile 작성의 기본 구조와 주요 명령어는 다음과 같다.

- `FROM`: 모든 Dockerfile은 FROM 명령어로 시작해야 하며, 이는 빌드 과정의 기점이 되는 이미지를 정의한다.

```DockerFile
FROM ubuntu:18.04
```

- `LABEL`: 이미지에 메타데이터를 추가한다. 예를 들어, 이미지의 제작자 정보를 포함할 수 있다.

```DockerFile
LABEL maintainer="name@example.com"
```

- `RUN`: 이미지 빌드 과정 중에 명령어를 실행한다. 주로 패키지 설치나 설정 파일 변경에 사용된다.

```DockerFile
RUN apt-get update && apt-get install -y python
```

- `COPY`: 호스트의 파일이나 디렉토리를 이미지 내부로 복사한다. `애플리케이션의 소스 코드`를 이미지에 추가할 때 주로 사용된다.

```DockerFile
COPY . /app
```

- `ADD`: COPY 명령어와 유사하지만, 원격 URL에서 파일을 추가하거나 로컬의 압축 파일을 압축 해제하며 파일을 추가할 수 있다.

```DockerFile
ADD https://example.com/big.tar.xz /usr/src/things/
```

- `CMD`: 컨테이너가 시작될 때 실행할 기본 명령어를 정의한다. Dockerfile 내에서 한 번만 사용할 수 있다.

```DockerFile
CMD ["python", "./app/app.py"]
```

- `EXPOSE`:컨테이너가 리스닝할 포트를 지정한다. 네트워킹 구성에 도움을 준다.

```DockerFile
EXPOSE 80
```

- `ENV`: 환경 변수를 설정한다. 애플리케이션 설정에 사용된다.

```DockerFile
ENV API_KEY="YOUR_API_KEY"
```

- `WORKDIR`: RUN, CMD, ENTRYPOINT, COPY, ADD 명령어가 실행될 작업 디렉토리를 설정한다.

```DockerFile
WORKDIR /app
```

- `ENTRYPOINT`: 컨테이너가 시작될 때 실행할 기본 명령어를 정의한다. Dockerfile 내에서 한 번만 사용할 수 있다.

```DockerFile
ENTRYPOINT ["python"]
CMD ["app.py"]
```

작성한 이후 `docker build 명령어`를 통해 이미지를 빌드할 수 있다. 이때 Dockerfile 내의 지시어들이 순서대로 실행되어 최종 이미지가 생성된다. Dockerfile을 활용함으로써 애플리케이션의 빌드와 배포 과정을 표준화하고 자동화할 수 있으며, 이는 개발의 효율성을 높이는 데 기여한다.

## 도커 이미지 최적화 방법

도커 이미지 크기를 줄이면 배포 시간을 단축시킬 수 있다.

### 1. 경량 베이스 이미지 사용하기

### 2. 멀티 스테이지 빌드 사용하기

Dockerfile에서 `멀티 스테이지 빌드`를 사용하여 빌드 단계에만 필요한 도구를 최종 이미지에서 제외시킨다. 이 방식을 사용하면 최종 이미지에는 애플리케이션 실행에 필요한 파일과 디펜던시만 포함된다. 멀티 스테이지 빌드는 여러 개의 FROM 명령어를 사용하여 구현되며, 각 스테이지는 독립적인 베이스 이미지를 가질 수 있다. 첫 번째 스테이지에서는 빌드에 필요한 도구와 소스 코드를 컴파일하는 데 필요한 작업을 수행한다. 이후 스테이지에서는 첫 번째 스테이지에서 생성된 아티팩트만을 가져와서 최종 이미지를 생성한다. 이렇게 하면 불필요한 빌드 도구나 중간 생성물을 최종 이미지에서 제외할 수 있어 이미지 크기가 상당히 줄어든다.

### 3. 필요 없는 파일 제거하기

빌드 과정에서 생성되는 임시 파일, 캐시 파일 등 필요 없는 파일은 RUN 명령어에서 && rm -rf /path/to/temporary/files와 같이 제거하여 이미지 크기를 줄인다.

### 4. 레이어 수 최소화하기

UN, COPY, ADD 명령어는 새로운 레이어를 생성한다. 이러한 명령어를 적절히 조합하여 가능한 한 적은 수의 레이어를 생성하도록 Dockerfile을 최적화한다.

### 5. COPY와 ADD 명령어를 신중하게 사용하기

COPY와 ADD는 필요한 파일만 이미지에 추가하도록 사용한다. .dockerignore 파일을 사용하여 불필요한 파일이 이미지에 포함되지 않도록 설정할 수 있다.

### 6. 환경 변수를 이용한 설정하기

가능한 설정 파일 대신 환경 변수를 사용하여 애플리케이션을 구성한다. 이 방법은 설정 변경이 필요할 때 이미지를 다시 빌드하지 않아도 되므로 이미지 크기를 줄이는 데 도움이 된다.

### 7. 적절한 태그 사용하기

## 호스트 간 파일 복사하기

`docker cp` 는 실행 중인 도커 컨테이너와 호스트 사이에서 파일이나 디렉토리를 복사하는 데 사용된다. 이 명령어는 컨테이너의 파일 시스템과 호스트의 파일 시스템 간의 데이터를 쉽게 이동할 수 있게 해준다. 또한 로그 파일, 설정 파일, 애플리케이션의 데이터 등 컨테이너 내부나 외부에서 필요한 데이터를 쉽게 이동시키는 데 유용하다. 그러나, 컨테이너의 실행 중인 서비스에 필수적인 파일을 변경하거나 삭제할 때는 주의가 필요하다.

- [container/cp](https://docs.docker.com/reference/cli/docker/container/cp/)
- [How to copy files from host to Docker container?](https://stackoverflow.com/questions/22907231/how-to-copy-files-from-host-to-docker-container/54970242#54970242)

### 기본 구조

- 호스트에서 컨테이너로 파일이나 디렉토리 복사하기

```bash
docker cp <호스트의 파일 경로> <컨테이너 이름>:<컨테이너 내 경로>
```

예를 들어, 호스트의 myfile.txt를 mycontainer라는 이름의 컨테이너의 /usr/src/app 디렉토리로 복사하고 싶다면, 다음과 같이 실행한다

```bash
docker cp myfile.txt mycontainer:/usr/src/app/myfile.txt
```

컨테이너에서 호스트로 파일이나 디렉토리 복사하기

```bash
docker cp <컨테이너 이름>:<컨테이너 내 파일 경로> <호스트의 경로>
```

예를 들어, mycontainer 컨테이너의 /usr/src/app/myfile.txt를 호스트의 현재 작업 디렉토리로 복사하고 싶다면, 다음과 같이 실행한다.

```bash
docker cp mycontainer:/usr/src/app/myfile.txt ./myfile.txt

```

## Network

컨테이너와 컨테이너를 따로 따로 만들면 그냥 연결이 될까?? no!
가상 네트워크를 만들어서 이 네트워크에 컨테이너를 소속시켜 컨테이너들을 연결해야 한다.

### Docker network 의 종류

### 브리지 네트워크 (Bridge Network)

<img width="628" alt="스크린샷 2024-04-05 오후 11 13 56" src="https://github.com/cocorig/docker-ci-cd/assets/95855640/15160bd8-7a01-4835-b576-c7521cd38a57">
<img width="691" alt="스크린샷 2024-04-05 오후 11 14 05" src="https://github.com/cocorig/docker-ci-cd/assets/95855640/6181668c-3d3f-479f-b85b-ae794de92f9b">

기본적으로, 각 도커 설치에는 `하나의 브리지 네트워크`가 존재하며, 컨테이너를 실행할 때 이 네트워크에 `자동`으로 연결된다. 사용자는 여러 개의 사용자 정의 브리지 네트워크를 생성하여 컨테이너를 논리적으로 `분리`할 수 있다.
같은 브리지 네트워크에 속한 컨테이너끼리는 서로 통신할 수 있지만, `다른 브리지 네트워크에 속한 컨테이너와는 통신할 수 없다`. 이를 통해 애플리케이션의 컴포넌트를 `격리`할 수 있다
`브릿지 네트워크`는 도커 컨테이너들이 `동일한 호스트 내에서` 서로 통신할 수 있도록 하는 기본 네트워크 타입 중 하나다.
이 네트워크는 `가상의 브릿지(bridge)`를 통해 각 컨테이너를 연결하며, 이를 통해 컨테이너 간에 데이터를 주고받을 수 있다. 브릿지 네트워크는 컨테이너가 생성될 때 자동으로 생성되는 기본 네트워크(bridge)와 사용자가 직접 생성할 수 있는 사용자 정의 브릿지 네트워크로 구분할 수 있다.

## reference

- 원티드 프리온보딩 과정
- 이미지 출처 : docker공식문서, geeksforgeeks
- [docker.docs](https://docs.docker.com/guides/walkthroughs/run-a-container/#step-3-build-your-first-image)
- [CLI Cheat Sheet](https://docs.docker.com/get-started/docker_cheatsheet.pdf)
- [Docker CLI 기본 명령어](https://docs.docker.com/reference/cli/docker/)
  <br>
