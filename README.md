# docker 🐳

Docker는 애플리케이션을 개발, 제공 및 실행하기 위한 개방형 플랫폼으로, Docker를 사용하면
개발자는 동일한 환경애서 애플리케이션을 개발하고, Docker 이미지를 사용해 테스트 및 프로덕션 환경에 배포할 수 있기 때문에 개발 환경과 프로덕션 환경의 실행 지연 시간을 크게 줄일 수 있다.

## 컨테이너화 (Containerization)

![스크린샷 2024-04-03 오전 2 45 32](https://github.com/cocorig/docker-ci-cd/assets/95855640/b2bc9ebf-99a6-453e-a174-59467566f7c4)

1960-70년대에는 일반적으로 한 컴퓨터가 한 애플리케이션 실행을 담당했기 때문에 프로세스 관리도 오래 걸렸다. 이 시기에는 `커널`이 `프로세스`의 생성부터 종료까지 전 생명 주기를 관리하고, 프로세스들이 `시스템 자원`을 효율적으로 사용하도록 조정하는 역할을 수행했다. 이를 통해 사용자와 애플리케이션은 안정적이고 효율적인 시스템 환경에서 작업을 수행할 수 있었다.

그러나 컴퓨팅 환경이 발전함에 따라 다중 사용자 및 다중 애플리케이션 환경이 보편화되면서 이러한 방식의 한계가 발생했다. 컴퓨터 자원을 최대한 공유하여 프로세스를 빠르게 실행하려 했지만, 서로 다른 사용자 간에 리소스를 공유하는 경우에는 각각의 프로세스가 원하는 리소스를 충분히 확보하지 못할 수 있는 문제가 발생했다. 즉 효율적으로 사용하려면 자원을 분리해서 사용해야 되는 것이다.
이러한 문제를 해결하기 위해 가상화 기술(Virtual Machine)이 도입되었다.
`하이퍼바이저 가상화`는 하드웨어 상에 여러 개의 독립적인 가상 운영 체제(가상 머신)를 실행할 수 있게 해주는 기술이다. 가상화를 통해 하나의 물리적 시스템에서 여러 개의 가상 환경을 만들어 각각의 환경에서 독립적으로 애플리케이션을 실행할 수 있게 되었다. `하이퍼바이저 가상화의 핵심`은 `하이퍼바이저`라는 소프트웨어에 있다.
`하이퍼바이저`는 물리적 하드웨어와 가상 머신 사이에서 `중재자 역할`을 하며, 하드웨어 자원(CPU, 메모리, 스토리지 등)을 가상 머신에게 분배하고, 가상 머신들이 이 자원을 안전하고 효율적으로 사용할 수 있도록 관리한다.
이러한 가상화를 통해, 개발자는 `다양한 운영 체제 위`에서 애플리케이션을 `테스트`하고, IT 관리자는 서버를 더 효율적으로 활용하여 비용을 절감할 수 있다.
또한, 하나의 리눅스 커널 위에서 여러 개의 독립적인 사용자 공간 인스턴스를 실행할 수 있게 해준다. VM과 다른 방법을 사용해서 효율 성능이 더 나아진게 `컨테이너`이다.
`컨테이너 가상화`는 애플리케이션을 실행하는 데 필요한 코드, 런타임, 시스템 도구, 시스템 라이브러리 등을 가상 머신포함하는 `가벼운 격리된 환경`을 생성하는 기술이다.
리눅스의 두 가지 격리 기술(Control Groups, Namespace)을 기반으로 사용함으로써, `컨테이너 가상화`는 각 컨테이너에게 완전히 독립된 시스템처럼 보이는 환경을 제공한다. 이는 개발자가 애플리케이션을 개발하고 배포할 때 발생할 수 있는 문제를 줄여줄 수 있다.

여기서 컨테이너와 가상 머신의 유사점과 차이점을 알아보자.

## 컨테이너와 VM(가상 머신) 비교

- `유사점`
  같은 가상기술로서 도커와 가상 머신은 모두 이미지에서 생성된다. 각 이미지를 사용하면 개발자는 환경을 매번 구성하지 않고 일관된 환경을 만들고 공유할 수 있게된다. 가상 머신 이미지는 운영 체제 백업을 생성하고,반면 도커 컨테이너 이미지는 애플리케이션 환경 백업을 생성한다.
  또한 각 이미지 모두 버전 관리를 통해 환경 구성 변경을 추적할 수 있고, 모두 서로 다른 유형의 기본 아키텍처에 대해 서로 다른 애플리케이션 구성을 개발해야 하는 어려움을 해결하도록 설계되었다.

- `차이점`
  가상 머신은 하드웨어에 `미리 일정량의 리소스를 요청`하며 가상 머신이 실행되는 한 계속해서 해당 양만큼 사용하고, 반면 컨테이너는 가상 머신과 달리 , `단일 운영 체제 커널`에서 `필요한 리소스만 `요청해 여러 컨테이너가 동일한 운영 체제를 공유하기 때문에 여러 컨테이너가 동일한 시스템에서 실행될 수 있으며 커널을 다른 컨테이너와 공유할 수 있다.
  또한 컨테이너 이미지의 크기는 일반적으로 MB이기 때문에 더 많은 애플리케이션을 처리할 수 있고,
  가상 머신에 비해 더 적은 수의 가상 머신 및 운영 체제가 필요하기 때문에 더 가볍다.
  또한 VM은 애플리케이션의 종속성과 커널 및 호스트 운영 체체와 함께 실행되고, 도커 컨테이너에는 종속성(애플리케이션과 라이브러리 등)만 포함되기 때문에 도커가 더 가볍다고 할 수 있다. 반면 가상 머신은 가상 머신 안에서 실행되는 운영 체제인 게스트 운영 체제(guest operating system)이 포함되고, 이 가상머신은 하이퍼바이저를 사용해 단일 시스템에서 여러 VM을 실행할 수 있지만, 각각의 VM이 완전한 운영 체제 및 응용 프로그램을 갖고 있기 때문에,
  가상 머신이 실행되는 데에는 해당 운영 체제와 관련된 모든 것이 필요하므로 전체 복사본이 필요하므로, GB를 차지한다. 따라서 VM의 부팅 속도도 느려질 수 있다.

## 도커 주요 장점

1.  Docker 컨테이너는 가상 머신에 비해 작고 가볍기 때문에 컨테이너를 개발, 테스트 및 배포를 더 빠르게 수행할 수 있다.
2.  어떤 환경에서든 동일하게 실행될 수 있기 때문에 어디든 쉽게 이동해 사용할 수 있다.(이식성)
3.  여러 플랫폼에 배포할 구 있는 기능을 갖추고 있다.
4.  Docker는 하이퍼바이저를 사용하지 않기 때문에 사용 가능한 리소스를 보다 효율적으로 사용한다.
5.  테스트 및 프로덕션과 같은 `다양한 환경`에 애플리케이션 `배포` 시의 `문제를 해결`할 수 있다.

## 용어정리

- `Docker Image` : `Image`는 애플리케이션 실행에 필요한 모든 것을 포함한다. 예를 들어
  애플리케이션과 관련된 라이브러리, 환경 변수 및 설정 파일,코드 등을 예로 들 수 있다.
  그럼 `Docker Image`는 `Docker container`를 실행하는 데 필요한 모든 것을 포함하는 것으로, 애플리케이션을 다양한 환경에서 일관되게 실행할 수 있다. 즉, container를 실행하기 위한 `불변의 템블릿`이라고 할 수 있다.(도장처럼 계속 사용가능하다.)
  또한, `Docker Image`는 여러 계층(layer)으로 구성되어 있으며,각 계층은 파일 시스템의 변경 사항을 저장한다. 일반적으로 도커허브와 같은 레지스트리에서 가져오거나 Dockerfile을 사용해 직접 빌드할 수 있다.
- `Docker container` : `Docker container`는 `Docker Image`의 실행 인스턴스이다.
  container는 Image를 기반으로 실행되며, 격리된 횐경에서 애플리케이션과 의존성을 `캡슐화` 하기 때문에 개발자는 동일한 Image를 사용하여 여러 container를 동시에 실행할 수 있으며, 각 container는 `독립적`으로 실행되고 관리된다. 즉 한 container의 문제가 다른 container에 영향을 미치지 않는다.
- `하이퍼바이저` : 가상화 환경을 생성하고, 관리하는 소프트웨어이다.
  주요 역할은 하나의 물리적 시스템 상에 `여러 개의 독립된 가상 머신(VM)을 실행`할 수 있는 환경을 제공하는 것이다.
- `리소스 관리`: 도커 엔진은 Cgroups와 네임스페이스와 같은 리눅스의 핵심 기능을 사용하여 컨테이너의 리소스 사용량을 제한하고, 컨테이너 간의 격리를 유지한다. 이를 통해 시스템의 안정성을 보장하고, 다른 컨테이너나 시스템 전체에 부정적인 영향을 미치는 것을 방지한다.

## 도커를 배우는 이유?

개발 단계에서 오류가 발생하지 않더라도 배포 후에 예상치 못한 문제가 발생할 수 있기 때문에
애플리케이션의 안정성을 점검하고 싶었고, 개발환경과 운영환경을 일치시키기 편리하기 때문이다.

## 왜 배포가 편리해야 할까?

서비스나 애플리케이션의 안정성이나 기능에 문제가 발생할 경우, 빠르게 수정하고 배포해야 한다. 안정성이 떨어지면 사용자들의 신뢰도가 저하되고 비즈니스에 부정적인 영향을 미칠 수 있으므로 빠른 대응이 필요하다.
또한 효율적인 배포는 운영 비용을 절감할 수 있다. 수동 작업이 줄어들고 자동화된 프로세스를 통해 운영 및 유지보수 비용을 최소화할 수 있다.

## 도커의 구성요소

도커 엔진 (Docker Engine)은 컨테이너를 생성하고 관리하는 기능을 제공하는 `클라이언트-서버 형태`의 애플리케이션이다.

1.  `Docker 클라이언트 및 서버`
    도커 데몬은 모든 컨테이너로 구성되며, CLI 또는 REST API를 통해 Docker 클라이언트로부터 요청을 수신하고, 처리한다. 또한 컨테이너의 생성, 실행, 중지와 같은 생명 주기를 관리한고, 도커 데몬은 다른 도커 클라이언트의 명령을 수행하기 위해 REST API를 통해 접근할 수 있다.
2.  `Docker 이미지`
    Docker 컨테이너를 빌드하는 데 사용된다.
3.  `Dockerfile`
    Docker 이미지를 자동으로 빌드하기 위한 스크립트 파일이다.이 이미지는 프로젝트의 종속성과 코드가 포함된다. 또한 docker build 명령어와 함께 사용되어 새로운 도커 이미지를 생성한다.
4.  `Docker 레지스트리`
    도커 이미지를 저장하고 배포하기 위한 서버 측 응용 프로그램이다. 보안, 액세스 제어, 저장소 한계 설정 등을 사용자가 직접 구성할 수 있게 해주며, 개인 또는 조직 내부에서 사용할 수 있는 프라이빗 저장소를 만들 수 있게 해준다.
5.  `Docker 컨테이너`
    이미지를 기반으로 하여 실행된다.

## 도커 구조

![Group 6](https://github.com/cocorig/docker-ci-cd/assets/95855640/9e992a75-b268-4566-b915-4201532736f2)

도커 아키텍처는 도커 클라이언트, 도커 호스트에서 실행되는 도커 데몬, 도커 허브 리포지토리로 구성된다.

- `Docker 이미지를 빌드`

  - (1) Docker Daemon에 대한 `빌드 명령`을 실행한다
  - (2) Docker Daemon은 해당 입력에 기반하여 `이미지를 빌드`한다.
  - (3) 빌드된 이미지를 Docker `레지스트리에 저장`한다.

- `이미지를 생성하지 않으려면`

  - (4) 클라이언트에서 `pull 명령`을 실행하여 Docker Daemon이 Docker Hub에서 이미지를 가져오도록 한다.

- `이미지를 실행하려는 경우`

  - (5) 클라이언트에서 `run 명령`을 실행
  - (6) 해당 이미지가 `컨테이너로 생성`된다.

## 동작방식

![Group 7](https://github.com/cocorig/docker-ci-cd/assets/95855640/59232d10-ee87-427d-afd1-2285452e58ce)

1. `이미지 다운로드 또는 빌드`: 컨테이너를 실행하기 전에, 도커 엔진은 해당 애플리케이션을 실행하는 데 필요한 모든 파일과 설정이 포함된 도커 이미지가 필요하다. 사용자는 도커 허브나 다른 이미지 저장소에서 이미지를 다운로드하거나, Dockerfile을 정의하고 이를 통해 새로운 이미지를 빌드할 수 있다.
2. `컨테이너 생성`: 이미지가 준비되면, 사용자는 도커 데몬에게 컨테이너 생성을 요청한다. 이때, 네트워크 설정이나 볼륨 마운트와 같은 추가적인 옵션을 지정할 수 있다. 도커 데몬은 이러한 정보를 바탕으로 새로운 컨테이너의 인스턴스를 생성한다.
3. `컨테이너 실행`: 컨테이너가 생성되면, 도커 데몬은 컨테이너 내부에서 정의된 애플리케이션을 실행한다. 이 과정에서 컨테이너는 독립된 파일 시스템, 네트워크 인터페이스, 프로세스 ID 공간 등을 갖게 되며, 이는 컨테이너를 호스트 시스템과 격리된 환경에서 실행되게 한다.
4. `컨테이너 관리`: 도커 엔진은 실행 중인 컨테이너의 상태를 모니터링하고 관리한다. 사용자는 도커 CLI를 통해 실행 중인 컨테이너를 조회하고, 로그를 확인하며, 필요한 경우 컨테이너를 중지, 재시작 또는 삭제할 수 있다.

## Docker Compose

- 예시

```yaml
# docker 컨테이너 버전 명시
version: "3"

# services는 컨테이너
services:
  db:
    # 컨테이너 이름 설정
    container_name:
		# 컨테이너 재시작 정책 설정
    restart: always
    # 사용할 이미지 지정
    image:
		# 현재 경로에 이미지 빌드
		build:
		# 포트 포워딩
		ports:
			- "8080:3000"
		# 볼륨 설정
		volumes:
			-
		# 환경 변수 설정
		environment:

```

Docker Compose는 다중 컨테이너 애플리케이션을 손쉽게 관리할 수 있는 도구로 여러 개의 컨테이너로 구성된 애플리케이션을 더 간편하게 구성하고 실행할 수 있다. 예를 들어 react와 PostgreSQL이 필요한 애플리케이션을 만들고자 한다면, 이 두 컨테이너를 하나의 YAML 파일에 서비스로 정의할 수 있다.
[Compose 작성 템플릿 코드](https://github.com/docker/awesome-compose)

```bash
docker compose up
```

## Docker 기본 명령어

- 현재 실행 중인 컨테이너 목록을 표시

```bash
docker ps
```

- Docker 엔진의 버전을 표시

```bash
docker --version
```

- 새로운 컨테이너를 실행

```bash
docker run
```

docker run = docker pull + docker create + docker start

- Docker 이미지를 다운로드

```bash
docker pull

```

- 컨테이너를 생성, 실행 x

```bash
docker create
```

- 정지된 컨테이너를 시작

```bash
docker start
```

- 실행 중인 컨테이너를 중지

```bash
docker stop
```

- 실행 중인 컨테이너를 다시 시작

```bash
docker restart
```

- 컨테이너 제거

```bash
docker rm
```

- 이미지 제거(컨테이너 삭제 후 진행해야함)

```bash
docker rmi
```

- 이미지 빌드

```bash
docker build
```

## reference

- 원티드 프리온보딩 과정
- 이미지 출처 : docker공식문서, geeksforgeeks
- [docker.docs](https://docs.docker.com/guides/walkthroughs/run-a-container/#step-3-build-your-first-image)
- [CLI Cheat Sheet](https://docs.docker.com/get-started/docker_cheatsheet.pdf)
- [Docker CLI 기본 명령어](https://docs.docker.com/reference/cli/docker/)
  <br>
